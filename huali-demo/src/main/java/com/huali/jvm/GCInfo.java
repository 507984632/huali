package com.huali.jvm;

/**
 * 什么是GC（分代收集算法）
 * 1. 次数上频率收集 Young 区
 * 2. 次数上较少收集区
 * 3. 基本不动元空间
 * <p>
 * GC4大算法
 * 概述：堆中 存有两个东西(三个的说明白元空间不是在 堆中，在物理内存中即可) 伊甸园 和 老年代
 * 而一般 伊甸园中存活 超过15代的才会进入 老年代中，所以一般 GC 只是清理 伊甸园中的内存对象， 而Full GC 是全部堆的内存对象，
 * 所以一般 Full GC 会比 GC 执行慢上10 倍左右
 * <p>
 * 1. 引用计数法
 * 如果有别的引用着这个对象，就在这个对象上加1 ，如果如果取消引用，则就减1 ，当等于0 的时候，说明这个是一个垃圾对象
 * 劣势：每次对对象赋值都要维护引用计数器，存在一定的消耗， 且 较难处理循环引用
 * <p>
 * <p>
 * 2. 复制算法（是在新生代中）
 * 执行清理对象后，将存活的对象从伊甸园区 赋值到 幸存者 TO 区，再将 幸存者 From 区中的对象进行判断是否存活达到 老年代的次数，达到的放到老年代
 * 达不到还活着的 复制到 幸存者 TO 区中，然后将 幸存者 From 变成 幸存者 TO 区，将幸存者 TO 区变成 幸存者 From 区
 * 优势：处理过程块，所需内存碎片少
 * 劣势：需要的空间 * 2， 且对象存活率要非常低
 * <p>
 * 3. 标记清除（老年代中）
 * 当内存快被耗尽，GC 就会将程序暂停，将需要回收的对象进行标记出来，然后同一进行回收，完成标记清理工作后，再将程序恢复运行
 * 优势：不需要额外的空间
 * 劣势：消耗时间长，产生过多的内存碎片
 * <p>
 * 4. 标记压缩(老年代中)   是标记清除 和标记整理的混合结果，但是这个最明显的是耗时上最长
 * 先标记清除的对象，然后再次扫描并将存活的对象移动到左端，最后清除对象
 * 优势：没有碎片，没有额外的内存开销
 * 劣势：所需时间成本增多
 * <p>
 * <p>
 * 总结
 * 内存效率：复制算法 》 标记清除 》标记整理
 * 内存整齐度： 复制算法 = 标记整理 》 标记清除
 * 内存利用率：标记整理 》 标记清除 》 复制算法
 * <p>
 * java 9 中 新增了 G1 GC 可以查询一下
 */
public class GCInfo {
    public static void main(String[] args) {

    }
}
